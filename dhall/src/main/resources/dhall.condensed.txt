
def text_literal[$: P] = P(
    (double_quote_literal / single_quote_literal)
)
def bytes_literal[$: P] = P(
    // Hexadecimal with "0x" prefix
    // %x22 = '"'
      "0" %x78 %x22 *(HEXDIG HEXDIG) %x22
)
def if[$: P] = P(
    %x69.66
)
def then[$: P] = P(
    %x74.68.65.6e
)
def else[$: P] = P(
    %x65.6c.73.65
)
def let[$: P] = P(
    %x6c.65.74
)
def in[$: P] = P(
    %x69.6e
)
def as[$: P] = P(
    %x61.73
)
def using[$: P] = P(
    %x75.73.69.6e.67
)
def merge[$: P] = P(
    %x6d.65.72.67.65
)
def missing[$: P] = P(
    %x6d.69.73.73.69.6e.67
)
def Infinity[$: P] = P(
    %x49.6e.66.69.6e.69.74.79
)
def NaN[$: P] = P(
    %x4e.61.4e
)
def Some[$: P] = P(
    %x53.6f.6d.65
)
def toMap[$: P] = P(
    %x74.6f.4d.61.70
)
def assert[$: P] = P(
    %x61.73.73.65.72.74
)
def forall_keyword[$: P] = P(
    %x66.6f.72.61.6c.6c // "forall"
)
def forall_symbol[$: P] = P(
    %x2200 // Unicode FOR ALL
)
def forall[$: P] = P(
    forall_symbol / forall_keyword
)
def with[$: P] = P(
    %x77.69.74.68
)
def showConstructor[$: P] = P(
    %x73.68.6f.77.43.6f.6e.73.74.72.75.63.74.6f.72
)
def keyword[$: P] = P(
      if / then / else
    / let / in
    / using / missing
    / assert / as
    / Infinity / NaN
    / merge / Some / toMap
    / forall_keyword
    / with
    / showConstructor
)
def builtin[$: P] = P(
      Natural_fold
    / Natural_build
    / Natural_isZero
    / Natural_even
    / Natural_odd
    / Natural_toInteger
    / Natural_show
    / Integer_toDouble
    / Integer_show
    / Integer_negate
    / Integer_clamp
    / Natural_subtract
    / Double_show
    / List_build
    / List_fold
    / List_length
    / List_head
    / List_last
    / List_indexed
    / List_reverse
    / Text_show
    / Text_replace
    / Date_show
    / Time_show
    / TimeZone_show
    / Bool
    / True
    / False
    / Optional
    / None
    / Natural
    / Integer
    / Double
    / Text
    / Date
    / Time
    / TimeZone
    / List
    / Type
    / Kind
    / Sort
)
def Optional[$: P] = P(
    %x4f.70.74.69.6f.6e.61.6c
)
def Text[$: P] = P(
    %x54.65.78.74
)
def List[$: P] = P(
    %x4c.69.73.74
)
def Location[$: P] = P(
    %x4c.6f.63.61.74.69.6f.6e
)
def Bool[$: P] = P(
    %x42.6f.6f.6c
)
def True[$: P] = P(
    %x54.72.75.65
)
def False[$: P] = P(
    %x46.61.6c.73.65
)
def None[$: P] = P(
    %x4e.6f.6e.65
)
def Natural[$: P] = P(
    %x4e.61.74.75.72.61.6c
)
def Integer[$: P] = P(
    %x49.6e.74.65.67.65.72
)
def Double[$: P] = P(
    %x44.6f.75.62.6c.65
)
def Date[$: P] = P(
    %x44.61.74.65
)
def Time[$: P] = P(
    %x54.69.6d.65
)
def TimeZone[$: P] = P(
    %x54.69.6d.65.5a.6f.6e.65
)
def Type[$: P] = P(
    %x54.79.70.65
)
def Kind[$: P] = P(
    %x4b.69.6e.64
)
def Sort[$: P] = P(
    %x53.6f.72.74
)
def Natural_fold[$: P] = P(
    %x4e.61.74.75.72.61.6c.2f.66.6f.6c.64
)
def Natural_build[$: P] = P(
    %x4e.61.74.75.72.61.6c.2f.62.75.69.6c.64
)
def Natural_isZero[$: P] = P(
    %x4e.61.74.75.72.61.6c.2f.69.73.5a.65.72.6f
)
def Natural_even[$: P] = P(
    %x4e.61.74.75.72.61.6c.2f.65.76.65.6e
)
def Natural_odd[$: P] = P(
    %x4e.61.74.75.72.61.6c.2f.6f.64.64
)
def Natural_toInteger[$: P] = P(
    %x4e.61.74.75.72.61.6c.2f.74.6f.49.6e.74.65.67.65.72
)
def Natural_show[$: P] = P(
    %x4e.61.74.75.72.61.6c.2f.73.68.6f.77
)
def Natural_subtract[$: P] = P(
    %x4e.61.74.75.72.61.6c.2f.73.75.62.74.72.61.63.74
)
def Integer_toDouble[$: P] = P(
    %x49.6e.74.65.67.65.72.2f.74.6f.44.6f.75.62.6c.65
)
def Integer_show[$: P] = P(
    %x49.6e.74.65.67.65.72.2f.73.68.6f.77
)
def Integer_negate[$: P] = P(
    %x49.6e.74.65.67.65.72.2f.6e.65.67.61.74.65
)
def Integer_clamp[$: P] = P(
    %x49.6e.74.65.67.65.72.2f.63.6c.61.6d.70
)
def Double_show[$: P] = P(
    %x44.6f.75.62.6c.65.2f.73.68.6f.77
)
def List_build[$: P] = P(
    %x4c.69.73.74.2f.62.75.69.6c.64
)
def List_fold[$: P] = P(
    %x4c.69.73.74.2f.66.6f.6c.64
)
def List_length[$: P] = P(
    %x4c.69.73.74.2f.6c.65.6e.67.74.68
)
def List_head[$: P] = P(
    %x4c.69.73.74.2f.68.65.61.64
)
def List_last[$: P] = P(
    %x4c.69.73.74.2f.6c.61.73.74
)
def List_indexed[$: P] = P(
    %x4c.69.73.74.2f.69.6e.64.65.78.65.64
)
def List_reverse[$: P] = P(
    %x4c.69.73.74.2f.72.65.76.65.72.73.65
)
def Text_show[$: P] = P(
    %x54.65.78.74.2f.73.68.6f.77
)
def Text_replace[$: P] = P(
    %x54.65.78.74.2f.72.65.70.6c.61.63.65
)
def Date_show[$: P] = P(
    %x44.61.74.65.2f.73.68.6f.77
)
def Time_show[$: P] = P(
    %x54.69.6d.65.2f.73.68.6f.77
)
def TimeZone_show[$: P] = P(
    %x54.69.6d.65.5a.6f.6e.65.2f.73.68.6f.77
)
def combine[$: P] = P(
    %x2227 / "/\"
)
def combine_types[$: P] = P(
    %x2A53 / "//\\"
)
def equivalent[$: P] = P(
    %x2261 / "==="
)
def prefer[$: P] = P(
    %x2AFD / "//"
)
def lambda[$: P] = P(
    %x3BB  / "\"
)
def arrow[$: P] = P(
    %x2192 / "->"
)
def complete[$: P] = P(
    "::"
)
def exponent[$: P] = P(
    "e" [ "+" / "-" ] 1*DIGIT
)
def numeric_double_literal[$: P] = P(
    [ "+" / "-" ] 1*DIGIT ( "." 1*DIGIT [ exponent ] / exponent)
)
def minus_infinity_literal[$: P] = P(
    "-" Infinity
)
def plus_infinity_literal[$: P] = P(
    Infinity
)
def double_literal[$: P] = P(
    // "-Infinity"
      minus_infinity_literal
    // "Infinity"
    / plus_infinity_literal
    // "NaN"
    / NaN
    // "2.0"
    / numeric_double_literal
)
def natural_literal[$: P] = P(
    // Hexadecimal with "0x" prefix
      "0" %x78 1*HEXDIG
    // Decimal; leading 0 digits are not allowed
    / ("1" / "2" / "3" / "4" / "5" / "6" / "7" / "8" / "9") *DIGIT
    // ... except for 0 itself
    / "0"
)
def integer_literal[$: P] = P(
    ( "+" / "-" ) natural_literal
)
def temporal_literal[$: P] = P(
    // "YYYY_MM_DDThh:mm:ss[+-]HH:MM", parsed as a `{ date : Date, time : Time, timeZone : TimeZone }`
      full_date "T" partial_time time_offset
    // "YYYY_MM_DDThh:mm:ss", parsed as a `{ date : Date, time : Time }`
    / full_date "T" partial_time
    // "hh:mm:ss[+-]HH:MM", parsed as a `{ time : Time, timeZone, TimeZone }`
    / partial_time time_offset
    // "YYYY_MM_DD", parsed as a `Date`
    / full_date
    // "hh:mm:ss", parsed as a `Time`
    / partial_time
    // "[+-]HH:MM", parsed as a `TimeZone`
    ;
    // Carefully note that this `time_numoffset` and not `time_offset`, meaning
    // that a standalone `Z` is not a valid Dhall literal for a `TimeZone`
    / time_numoffset
)
def date_fullyear[$: P] = P(
    4DIGIT
)
def date_month[$: P] = P(
    2DIGIT  // 01_12
)
def date_mday[$: P] = P(
    2DIGIT  // 01_28, 01_29, 01_30, 01_31 based on
                          // month/year
)
def time_hour[$: P] = P(
    2DIGIT  // 00_23
)
def time_minute[$: P] = P(
    2DIGIT  // 00_59
)
def time_second[$: P] = P(
    2DIGIT  // 00_59 (**UNLIKE** RFC 3339, we don't support leap
                          // seconds)
)
def time_secfrac[$: P] = P(
    "." 1*DIGIT  // RFC 3339
)
def time_numoffset[$: P] = P(
    ("+" / "-") time_hour ":" time_minute
)
def time_offset[$: P] = P(
    "Z" / time_numoffset  // "Z" desugars to "+00:00"
)
def partial_time[$: P] = P(
    time_hour ":" time_minute ":" time_second
                  [time_secfrac]
)
def full_date[$: P] = P(
    date_fullyear "-" date_month "-" date_mday
)
def identifier[$: P] = P(
    variable / builtin
)
def variable[$: P] = P(
    nonreserved_label [ whsp "@" whsp natural_literal ]
)
def path_character[$: P] = P(
        // %x20 = " "
      %x21
        // %x22 = "\""
        // %x23 = "#"
    / %x24_27
        // %x28 = "("
        // %x29 = ")"
    / %x2A_2B
        // %x2C = ","
    / %x2D_2E
        // %x2F = "/"
    / %x30_3B
        // %x3C = "<"
    / %x3D
        // %x3E = ">"
        // %x3F = "?"
    / %x40_5A
        // %x5B = "["
        // %x5C = "\"
        // %x5D = "]"
    / %x5E_7A
        // %x7B = "{"
    / %x7C
        // %x7D = "}"
    / %x7E
)
def quoted_path_character[$: P] = P(
      %x20_21
        // %x22 = "\""
    / %x23_2E
        // %x2F = "/"
    / %x30_7F
    / valid_non_ascii
)
def unquoted_path_component[$: P] = P(
    1*path_character
)
def quoted_path_component[$: P] = P(
    1*quoted_path_character
)
def path_component[$: P] = P(
    "/" ( unquoted_path_component / %x22 quoted_path_component %x22 )
)
def path[$: P] = P(
    1*path_component
)
def local[$: P] = P(
    parent_path
    / here_path
    / home_path
    // NOTE: Backtrack if parsing this alternative fails
    ;
    // This is because the first character of this alternative will be "/", but
    // if the second character is "/" or "\" then this should have been parsed
    // as an operator instead of a path
    / absolute_path
)
def parent_path[$: P] = P(
    ".." path  // Relative path
)
def here_path[$: P] = P(
    "."  path  // Relative path
)
def home_path[$: P] = P(
    "~"  path  // Home_anchored path
)
def absolute_path[$: P] = P(
    path  // Absolute path
)
def scheme[$: P] = P(
    %x68.74.74.70 [ %x73 ]  // "http" [ "s" ]
)
def http_raw[$: P] = P(
    scheme "://" authority path_abempty [ "?" query ]
)
def path_abempty[$: P] = P(
    *( "/" segment )
)
def authority[$: P] = P(
    [ userinfo "@" ] host [ ":" port ]
)
def userinfo[$: P] = P(
    *( unreserved / pct_encoded / sub_delims / ":" )
)
def host[$: P] = P(
    IP_literal / IPv4address / domain
)
def port[$: P] = P(
    *DIGIT
)
def IP_literal[$: P] = P(
    "[" ( IPv6address / IPvFuture  ) "]"
)
def IPvFuture[$: P] = P(
    "v" 1*HEXDIG "." 1*( unreserved / sub_delims / ":" )
)
def IPv6address[$: P] = P(
                               6( h16 ":" ) ls32
            /                       "::" 5( h16 ":" ) ls32
            / [ h16               ] "::" 4( h16 ":" ) ls32
            / [ h16 *1( ":" h16 ) ] "::" 3( h16 ":" ) ls32
            / [ h16 *2( ":" h16 ) ] "::" 2( h16 ":" ) ls32
            / [ h16 *3( ":" h16 ) ] "::"    h16 ":"   ls32
            / [ h16 *4( ":" h16 ) ] "::"              ls32
            / [ h16 *5( ":" h16 ) ] "::"              h16
            / [ h16 *6( ":" h16 ) ] "::"
)
def h16[$: P] = P(
    1*4HEXDIG
)
def ls32[$: P] = P(
    h16 ":" h16 / IPv4address
)
def IPv4address[$: P] = P(
    dec_octet "." dec_octet "." dec_octet "." dec_octet
)
def dec_octet[$: P] = P(
    "25" %x30_35       // 250_255
          / "2" %x30_34 DIGIT  // 200_249
          / "1" 2DIGIT         // 100_199
          / %x31_39 DIGIT      // 10_99
          / DIGIT              // 0_9
)
def domain[$: P] = P(
    domainlabel *("." domainlabel) [ "." ]
)
def domainlabel[$: P] = P(
    1*ALPHANUM *(1*"-" 1*ALPHANUM)
)
def segment[$: P] = P(
    *pchar
)
def pchar[$: P] = P(
    unreserved / pct_encoded / sub_delims / ":" / "@"
)
def query[$: P] = P(
    *( pchar / "/" / "?" )
)
def pct_encoded[$: P] = P(
    "%" HEXDIG HEXDIG
)
def unreserved[$: P] = P(
    ALPHANUM / "-" / "." / "_" / "~"
)
def sub_delims[$: P] = P(
    "!" / "$" / "&" / "'" / "*" / "+" / ";" / "="
)
def http[$: P] = P(
    http_raw [ whsp using whsp1 import_expression ]
)
def env[$: P] = P(
    "env:"
    ( bash_environment_variable
    / %x22 posix_environment_variable %x22
    )
)
def bash_environment_variable[$: P] = P(
    (ALPHA / "_") *(ALPHANUM / "_")
)
def posix_environment_variable[$: P] = P(
    1*posix_environment_variable_character
)
def posix_environment_variable_character[$: P] = P(
      %x5C                 // '\'    Beginning of escape sequence
      ( %x22               // '"'    quotation mark  U+0022
      / %x5C               // '\'    reverse solidus U+005C
      / %x61               // 'a'    alert           U+0007
      / %x62               // 'b'    backspace       U+0008
      / %x66               // 'f'    form feed       U+000C
      / %x6E               // 'n'    line feed       U+000A
      / %x72               // 'r'    carriage return U+000D
      / %x74               // 't'    tab             U+0009
      / %x76               // 'v'    vertical tab    U+000B
      )
    // Printable characters except double quote, backslash and equals
    / %x20_21
        // %x22 = '"'
    / %x23_3C
        // %x3D = '='
    / %x3E_5B
        // %x5C = "\"
    / %x5D_7E
)
def import_type[$: P] = P(
    missing / local / http / env
)
def hash[$: P] = P(
    %x73.68.61.32.35.36.3a 64HEXDIG // "sha256:XXX...XXX"
)
def import_hashed[$: P] = P(
    import_type [ whsp1 hash ]
)
def import[$: P] = P(
    import_hashed [ whsp as whsp1 (Text / Location) ]
)
def expression[$: P] = P(
    // "\(x : a) -> b"
      lambda whsp "(" whsp nonreserved_label whsp ":" whsp1 expression whsp ")" whsp arrow whsp expression
    ;
    // "if a then b else c"
    / if whsp1 expression whsp then whsp1 expression whsp else whsp1 expression
    ;
    // "let x : t = e1 in e2"
    // "let x     = e1 in e2"
    // We allow dropping the `in` between adjacent let_expressions; the following are equivalent:
    // "let x = e1 let y = e2 in e3"
    // "let x = e1 in let y = e2 in e3"
    / 1*let_binding in whsp1 expression
    ;
    // "forall (x : a) -> b"
    / forall whsp "(" whsp nonreserved_label whsp ":" whsp1 expression whsp ")" whsp arrow whsp expression
    ;
    // "a -> b"
    ;
    // NOTE: Backtrack if parsing this alternative fails
    / operator_expression whsp arrow whsp expression
    ;
    // "a with x = b"
    ;
    // NOTE: Backtrack if parsing this alternative fails
    / with_expression
    ;
    // "merge e1 e2 : t"
    ;
    // NOTE: Backtrack if parsing this alternative fails since we can't tell
    // from the keyword whether there will be a type annotation or not
    / merge whsp1 import_expression whsp1 import_expression whsp ":" whsp1 expression
    ;
    // "[] : t"
    ;
    // NOTE: Backtrack if parsing this alternative fails since we can't tell
    // from the opening bracket whether or not this will be an empty list or
    // a non_empty list
    / empty_list_literal
    ;
    // "toMap e : t"
    ;
    // NOTE: Backtrack if parsing this alternative fails since we can't tell
    // from the keyword whether there will be a type annotation or not
    / toMap whsp1 import_expression whsp ":" whsp1 expression
    ;
    // "assert : Natural/even 1 === False"
    / assert whsp ":" whsp1 expression
    ;
    // "x : t"
    / annotated_expression
)
def annotated_expression[$: P] = P(
    operator_expression [ whsp ":" whsp1 expression ]
)
def let_binding[$: P] = P(
    let whsp1 nonreserved_label whsp [ ":" whsp1 expression whsp ] "=" whsp expression whsp1
)
def empty_list_literal[$: P] = P(
    "[" whsp [ "," whsp ] "]" whsp ":" whsp1 expression
)
def with_expression[$: P] = P(
    import_expression 1*(whsp1 with whsp1 with_clause)
)
def with_clause[$: P] = P(
    with_component *(whsp "." whsp with_component) whsp "=" whsp operator_expression
)
def operator_expression[$: P] = P(
    equivalent_expression
)
def equivalent_expression[$: P] = P(
    import_alt_expression    *(whsp equivalent whsp import_alt_expression)
)
def import_alt_expression[$: P] = P(
    or_expression            *(whsp "?" whsp1 or_expression)
)
def or_expression[$: P] = P(
    plus_expression          *(whsp "||" whsp plus_expression)
)
def plus_expression[$: P] = P(
    text_append_expression   *(whsp "+" whsp1 text_append_expression)
)
def text_append_expression[$: P] = P(
    list_append_expression   *(whsp "++" whsp list_append_expression)
)
def list_append_expression[$: P] = P(
    and_expression           *(whsp "#" whsp and_expression)
)
def and_expression[$: P] = P(
    combine_expression       *(whsp "&&" whsp combine_expression)
)
def combine_expression[$: P] = P(
    prefer_expression        *(whsp combine whsp prefer_expression)
)
def prefer_expression[$: P] = P(
    combine_types_expression *(whsp prefer whsp combine_types_expression)
)
def combine_types_expression[$: P] = P(
    times_expression         *(whsp combine_types whsp times_expression)
)
def times_expression[$: P] = P(
    equal_expression         *(whsp "*" whsp equal_expression)
)
def equal_expression[$: P] = P(
    not_equal_expression     *(whsp "==" whsp not_equal_expression)
)
def not_equal_expression[$: P] = P(
    application_expression   *(whsp "!=" whsp application_expression)
)
def application_expression[$: P] = P(
    first_application_expression *(whsp1 import_expression)
)
def first_application_expression[$: P] = P(
    // "merge e1 e2"
      merge whsp1 import_expression whsp1 import_expression
    ;
    // "Some e"
    / Some whsp1 import_expression
    ;
    // "toMap e"
    / toMap whsp1 import_expression
    ;
    // "showConstructor e"
    / showConstructor whsp1 import_expression
    ;
    / import_expression
)
def import_expression[$: P] = P(
    import / completion_expression
)
def completion_expression[$: P] = P(
    selector_expression [ whsp complete whsp selector_expression ]
)
def selector_expression[$: P] = P(
    primitive_expression *(whsp "." whsp selector)
)
def selector[$: P] = P(
    any_label / labels / type_selector
)
def labels[$: P] = P(
    "{" whsp [ "," whsp ] [ any_label_or_some whsp *("," whsp any_label_or_some whsp) [ "," whsp ] ] "}"
)
def type_selector[$: P] = P(
    "(" whsp expression whsp ")"
)
def primitive_expression[$: P] = P(
      temporal_literal
    ;
    // "2.0"
    / double_literal
    ;
    // "2"
    / natural_literal
    ;
    // "+2"
    / integer_literal
    ;
    // '"ABC"'
    / text_literal
    ;
    // '0x"01234567689abcdef"'
    / bytes_literal
    ;
    // "{ foo = 1      , bar = True }"
    // "{ foo : Integer, bar : Bool }"
    / "{" whsp [ "," whsp ] record_type_or_literal whsp "}"
    ;
    // "< Foo : Integer | Bar : Bool >"
    // "< Foo | Bar : Bool >"
    / "<" whsp [ "|" whsp ] union_type whsp ">"
    ;
    // "[1, 2, 3]"
    / non_empty_list_literal
    ;
    // "x"
    // "x@2"
    / identifier
    ;
    // "( e )"
    / "(" complete_expression ")"
)
def record_type_or_literal[$: P] = P(
      empty_record_literal
    / [non_empty_record_type_or_literal]
)
def empty_record_literal[$: P] = P(
    "=" [ whsp "," ]
)
def non_empty_record_type_or_literal[$: P] = P(
    (non_empty_record_type / non_empty_record_literal)
)
def non_empty_record_type[$: P] = P(
    record_type_entry *(whsp "," whsp record_type_entry) [ whsp "," ]
)
def record_type_entry[$: P] = P(
    any_label_or_some whsp ":" whsp1 expression
)
def non_empty_record_literal[$: P] = P(
    record_literal_entry *(whsp "," whsp record_literal_entry) [ whsp "," ]
)
def record_literal_entry[$: P] = P(
    any_label_or_some [record_literal_normal_entry]
)
def record_literal_normal_entry[$: P] = P(
    *(whsp "." whsp any_label_or_some) whsp "=" whsp expression
)
def union_type[$: P] = P(
    [union_type_entry *(whsp "|" whsp union_type_entry) [ whsp "|" ]]
)
def union_type_entry[$: P] = P(
    any_label_or_some [ whsp ":" whsp1 expression ]
)
def non_empty_list_literal[$: P] = P(
    "[" whsp [ "," whsp ] expression whsp *("," whsp expression whsp) [ "," whsp ] "]"
)