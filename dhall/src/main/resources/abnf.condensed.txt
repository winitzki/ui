)
def ALPHA[$: P] = P(
     %x41_5A / %x61_7A   //  A_Z / a_z
)
def BIT[$: P] = P(
     "0" / "1"
)
def CHAR[$: P] = P(
     %x01_7F
                       //  any 7_bit US_ASCII character,
                       //   excluding NUL
)
def CR[$: P] = P(
     %x0D
                       //  carriage return
)
def CRLF[$: P] = P(
     CR LF
                       //  Internet standard newline
)
def CTL[$: P] = P(
     %x00_1F / %x7F
                       //  controls
)
def DIGIT[$: P] = P(
     %x30_39
                       //  0_9
)
def DQUOTE[$: P] = P(
     %x22
                       //  " (Double Quote)
)
def HEXDIG[$: P] = P(
     DIGIT / "A" / "B" / "C" / "D" / "E" / "F"
)
def HTAB[$: P] = P(
     %x09
                       //  horizontal tab
)
def LF[$: P] = P(
     %x0A
                       //  linefeed
)
def LWSP[$: P] = P(
     *(WSP / CRLF WSP)
                       //  Use of this linear_white_space rule
                       //   permits lines containing only white
                       //   space that are no longer legal in
                       //   mail headers and have caused
                       //   interoperability problems in other
                       //   contexts.
                       //  Do not use when defining mail
                       //   headers and use with caution in
                       //   other contexts.
)
def OCTET[$: P] = P(
     %x00_FF
                       //  8 bits of data
)
def SP[$: P] = P(
     %x20
)
def VCHAR[$: P] = P(
     %x21_7E
                       //  visible (printing) characters
)
def WSP[$: P] = P(
     SP / HTAB
                       //  white space
)
def rulelist[$: P] = P(
     1*( rule / (*c_wsp c_nl) )
)
def rule[$: P] = P(
     rulename defined_as elements c_nl
                       //  continues if next line starts
                       //   with white space
)
def rulename[$: P] = P(
     ALPHA *(ALPHA / DIGIT / "-")
)
def defined_as[$: P] = P(
     *c_wsp ("=" / "=/") *c_wsp
                       //  basic rules definition and
                       //   incremental alternatives
)
def elements[$: P] = P(
     alternation *c_wsp
)
def c_wsp[$: P] = P(
     WSP / (c_nl WSP)
)
def c_nl[$: P] = P(
     comment / CRLF
                       //  comment or newline
)
def comment[$: P] = P(
     ";" *(WSP / VCHAR) CRLF
)
def alternation[$: P] = P(
     concatenation
                  *(*c_wsp "/" *c_wsp concatenation)
)
def concatenation[$: P] = P(
     repetition *(1*c_wsp repetition)
)
def repetition[$: P] = P(
     [repeat] element
)
def repeat[$: P] = P(
     1*DIGIT / (*DIGIT "*" *DIGIT)
)
def element[$: P] = P(
     rulename / group / option /
                  char_val / num_val / prose_val
)
def group[$: P] = P(
     "(" *c_wsp alternation *c_wsp ")"
)
def option[$: P] = P(
     "[" *c_wsp alternation *c_wsp "]"
)
def char_val[$: P] = P(
     DQUOTE *(%x20_21 / %x23_7E) DQUOTE
                       //  quoted string of SP and VCHAR
                       //   without DQUOTE
)
def num_val[$: P] = P(
     "%" (bin_val / dec_val / hex_val)
)
def bin_val[$: P] = P(
     "b" 1*BIT
                  [ 1*("." 1*BIT) / ("-" 1*BIT) ]
                       //  series of concatenated bit values
                       //   or single ONEOF range
)
def dec_val[$: P] = P(
     "d" 1*DIGIT
                  [ 1*("." 1*DIGIT) / ("-" 1*DIGIT) ]
)
def hex_val[$: P] = P(
     "x" 1*HEXDIG
                  [ 1*("." 1*HEXDIG) / ("-" 1*HEXDIG) ]
)
def prose_val[$: P] = P(
     "<" *(%x20_3D / %x3F_7E) ">"
                        //  bracketed string of SP and VCHAR
                        //   without angles
                        //  prose description, to be used as
                        //   last resort
